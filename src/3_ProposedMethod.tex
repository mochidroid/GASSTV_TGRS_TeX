\section{Proposed Method}
\label{sec:ProposedMethod}


% Guide image

\subsection{Spectral Graph-based Weighted Difference Operator}
\label{subsec:WeightedSpectralDiff}
% Since we only obtain a noisy HS image in real situations, we propose a robust method for constructing the spectral graph via the guide image generated by Eq.~\eqref{eq:GuideImage}. k-means~\cite{Arthur2006kmeans}

In constructing the spectral graph from a noisy HS image, we assume that when the HS image is segmented, each segment contains similar spectral characteristics. 
Based on this assumption, we compute the guide image $\GuideImage$ that reflects the spatial structure of the target HS image according to Eq.~\eqref{eq:GuideImage}, and divide the guide image into segments $\Segment{\IndexSegment} (\IndexSegment = 1, \dots, \NumSegment)$ using the k-means clustering method~\cite{Arthur2006kmeans}. % Segmantationを数式にしたい
Let $\LabelMap \in \RealSpace{\NumVert \times \NumHori}$ denote the resulting label map, where $\LabelMap(\IndexVert, \IndexHori) = \IndexSegment$ indicates that the pixel at position $(\IndexVert, \IndexHori)$ belongs to segment $\Segment{\IndexSegment}$.

Next, for each segment, all pixels of the noisy HS image $\HSIObsv$ belonging to $\Segment{\IndexSegment}$ are averaged along the spatial direction to compute a representative spectrum $\SpectrumRep{\IndexSegment}$ as
\begin{equation}
    \label{eq:SpectrumRep}
    \SpectrumRep{\IndexSegment} := \frac{1}{|\Segment{\IndexSegment}|} \sum_{(\IndexVert, \IndexHori) \in \Segment{\IndexSegment}} \HSIObsv(\IndexVert, \IndexHori, :),
\end{equation}
where $\HSIObsv(\IndexVert, \IndexHori, :)$ denotes the spectral vector with length $\NumBand$ at location $(\IndexVert, \IndexHori)$.
By averaging the spectral vectors within each segment, the spectra of the segment can be effectively characterized while reducing noise.

Here, the representative spectra $\{ \SpectrumRep{1}, \ldots, \SpectrumRep{\NumSegment} \}$ are regarded as line graphs of length $\NumBand$.
Each representative spectrum is assigned to the pixels of its corresponding segment, and by doing so, we construct a spectral graph $\SpectralGraph(\SpectralGraphNode, \SpectralGraphEdgeSet, \SpectralGraphWeightMat)$ that consists of $\NumVert \times \NumHori$ line graphs.
The node vectors $\SpectralGraphNode$ are defined as follows: for all $\IndexVert$, $\IndexHori$
\begin{equation}
    \label{eq:SpectralGraphNode}
    \SpectralGraphNode(\IndexVert, \IndexHori, :) := \SpectrumRep{\LabelMap(\IndexVert, \IndexHori)},
\end{equation}
where $\SpectralGraphNode(\IndexVert, \IndexHori, :)$ represents the spectral vector of length $\NumBand$ at location $(\IndexVert, \IndexHori)$.
% The weight matrix $\SpectralGraphWeightMat \in \RealSpace{\NumAll \times \NumAll}$ is a diagonal matrix whose entries are the weights $\SpectralGraphWeight{} \in (0, 1]$ defined by
% % \begin{equation}
% %     \label{eq:SpectralGraphWeight}
% %     \SpectralGraphWeight{\IndexWeight} := \exp{\left( -\frac{[\DiffOpBand \SpectralGraphNode]_{\IndexWeight}^{2}}{2\ParamSpectralGraph^{2}} \right)},
% % \end{equation}
% \begin{equation}
%     \label{eq:SpectralGraphWeight}
%     \SpectralGraphWeight{\IndexWeight} := \exp{\left( -[\DiffOpBand \SpectralGraphNode]_{\IndexWeight}^{2} / 2\ParamSpectralGraph^{2}\right)},
% \end{equation}
% where $[\DiffOpBand \SpectralGraphNode]_{\IndexWeight}^{2}$ represents the $\IndexWeight$-th element of the product, and squaring is applied to each element.
% Then, the weighted spectral difference operator $\DiffOpGraphBand$ is defined via the graph $\SpectralGraph$ as follows:
% \begin{equation}
%     \label{eq:DiffSpectralGraph}
%     \DiffOpGraphBand := \SpectralGraphWeightMat \DiffOpBand.
% \end{equation}
The weight matrix $\SpectralGraphWeightMat \in \RealSpace{\NumAll \times \NumAll}$ is a diagonal matrix whose entries are the weights $\SpectralGraphWeight{} \in (0, 1]$ defined by
\begin{equation}
    \label{eq:SpectralGraphWeight}
    \SpectralGraphWeight{\IndexWeight} := \exp{\left( - \frac{[\DiffOpBand \SpectralGraphNode]_{\IndexWeight}^{2}}{2\ParamSpectralGraph^{2}}\right)},
\end{equation} % x_\lambda - x_\lambdaの形のほうがきれいかも
where $[\DiffOpBand \SpectralGraphNode]_{\IndexWeight}^{2}$ represents the $\IndexWeight$-th element of the product, and squaring is applied to each element.
Then, the weighted spectral difference operator $\DiffOpGraphBand$ is defined via the graph $\SpectralGraph$ as 
\begin{equation}
    \label{eq:SpectralGraphTV}
    \DiffOpGraphBand := \SpectralGraphWeightMat \DiffOpBand.
\end{equation}


\subsection{GASSTV}
\label{subsec:GASSTV}
Incorporating both the spatial graph $\SpatialGraph$ and the spectral graph $\SpectralGraph$, our \textit{Graph-Aided Spatio-Spectral Total Variation} (GASSTV) is defined as follows:
\begin{equation}
    \label{eq:GASSTV}
    \GASSTV(\HSIClean) := \| \DiffOpSp \DiffOpBand \HSIClean\|_{1} + \BalanceParamOne \| \DiffOpGraphSp \HSIClean \|_{1} + \BalanceParamTwo \| \DiffOpGraphBand \HSIClean \|_{1},
\end{equation}
where $\DiffOpSp := \begin{pmatrix} \DiffOpVertT & \DiffOpHoriT \end{pmatrix}^{\top} \in \RealSpace{2 \NumAll \times \NumAll}$ is the spatial difference operator, $\BalanceParamOne$ and $\BalanceParamTwo$ are the parameters.
The first term represents Spatio-Spectral Total Variation (SSTV)~\cite{Aggarwal2016SSTV}, while the second and third terms represent the spatial and spectral graph-based TV (spatial graph TV and spectral graph TV), respectively.
SSTV effectively removes noise and preserves spatio-spectral continuity but struggles to capture complex spatial structures and sharp spectral jumps, resulting in the loss of important details.
GASSTV addresses these issues by incorporating spatial and spectral graph TVs.
% Spatial graph TV captures complex spatial structures, while spectral graph TV preserves sharp spectral variations.
% By integrating these graph-based regularization terms with SSTV, GASSTV enhances noise removal while preserving crucial spatial and spectral details.
By capturing complex spatial structures and spectral jumps with spatial and spectral graph TVs, respectively, GASSTV enhances noise removal while preserving important spatial and spectral details.
% この部分の記述をもう少し頑張ろう


\subsection{Problem Formulation}
\label{subsec:ProbForm}
An observed HS image $\HSIObsv \in \RealSpace{\NumAll}$ contaminated by mixed noise is modeled by
\begin{equation}
    \label{eq:ObsvModel}
    \HSIObsv = \bar{\HSIClean} + \bar{\NoiseSparse} + \bar{\NoiseStripe} + \NoiseGauss,
\end{equation}
where $\bar{\HSIClean}$, $\bar{\NoiseSparse}$, $\bar{\NoiseStripe}$, and $\NoiseGauss$ represent a clean HS image, sparse noise such as outliers, stripe noise and random noise, respectively. % stripe noiseのところもう少し何か書く？

Based on the observation model~\eqref{eq:ObsvModel}, we formulate HS image denoising problem by GASSTV as a constrained convex optimization problem with the following form:
\begin{equation}
    \label{prob:OptimProb}
    \min_{\HSIClean, \NoiseSparse, \NoiseStripe} \GASSTV(\HSIClean) \quad \mathrm{s.t.} \: 
    \begin{cases}
        \HSIClean + \NoiseSparse \in \BallFidel, \\
        \NoiseSparse \in \BallSparse, \\
        \NoiseStripe \in \BallStripe, \\
        \DiffOpVert \NoiseStripe = \mathbf{0}, \\
        \HSIClean \in \SetRange, \\
    \end{cases}
\end{equation}
where
\begin{align}
    \label{eq:ConstL2ball}
    &\BallFidel := \{ \VarOne \in \RealSpace{\NumAll} | \:
    \|\VarOne - \HSIObsv\|_2 \leq \RadiusFidel \}, \\
    \label{eq:ConstL1ball}
    &\BallSparse := \{ \VarOne \in \RealSpace{\NumAll} | \:
    \|\VarOne\|_{1} \leq \RadiusSparse \}, \\
    \label{eq:ConstBox}
    &\SetRange := \{ \VarOne \in \RealSpace{\NumAll} | \:
    \MinRange \leq \ElementOne{\IndexOne} \leq \MaxRange  \: (\IndexOne = 1,\dots , \NumAll) \}.
\end{align}
The first constraint serves as data-fidelity with the $\HSIObsv$-centered $\ell_2$-ball of the radius $\RadiusFidel > 0$.
The second constraint characterizes sparse noise with the zero-centered $\ell_1$-ball of the radius $\RadiusSparse > 0$.
Since we impose the above constraints instead of adding terms to the objective function, it becomes easier to adjust the parameters.
These advantages are also addressed, for example, in~\cite{Afonso2011Constraint, chierchia2015Constraint, Ono2015Constraint, Ono2017Constraint, Ono2019Constraint}.
The third constraint is a box constraint which represents the dynamic range of $\HSIClean$.

% \input{algo_PPDS}


% \input{tab_results}
% \input{fig_result_image}
\subsection{Optimization}
\label{subsec:Optim}
We develop an efficient solver for Prob.~\eqref{prob:OptimProb} based on P-PDS~\cite{Pock2011PPDS}.
% Using the indicator functions, we rewrite Prob.~\eqref{prob:OptimProb} into an equivalent form:
% \begin{align}
%     \label{prob:OptimProb2PPDS}
%     \min_{
%     \substack{
%         \HSIClean, \NoiseSparse, \VarDual{1}, \VarDual{2}, \\ 
%         \VarDual{3}, \VarDual{4}, \VarDual{5}}} \:
%     & \|\VarDual{1} \|_{1} + \BalanceParamOne \|\VarDual{2} \|_{1} + \BalanceParamTwo \|\VarDual{3} \|_{1} \nonumber \\
%     & + \FuncIndicator{\BallFidel} (\HSIClean + \NoiseSparse) + \FuncIndicator{\BallSparse} (\VarDual{4}) + \FuncIndicator{\SetRange} (\VarDual{5})\nonumber \\
%     & \mathrm{s.t.} \:
%     \begin{cases} 
%     \VarDual{1} = \DiffOpSp \DiffOpBand \HSIClean, \\
%     \VarDual{2} = \DiffOpGraphSp \HSIClean, \\
%     \VarDual{3} = \DiffOpGraphBand \HSIClean, \\
%     \VarDual{4} = \NoiseSparse, \\
%     \VarDual{5} = \HSIClean.
%     \end{cases}
% \end{align}
Using the indicator functions, we rewrite Prob.~\eqref{prob:OptimProb} into an equivalent form:
\begin{align}
    \label{prob:OptimProb2PPDS}
    \min_{\HSIClean, \NoiseSparse} 
    & \|\DiffOpSp \DiffOpBand \HSIClean \|_{1} + \BalanceParamOne \|\DiffOpGraphSp \HSIClean \|_{1} + \BalanceParamTwo \|\DiffOpGraphBand \HSIClean \|_{1} \notag \\ 
    & + \FuncIndicator{\BallFidel} (\HSIClean + \NoiseSparse) + \FuncIndicator{\BallSparse} (\NoiseSparse) + \FuncIndicator{\SetRange} (\HSIClean).
\end{align}
Prob.~\eqref{prob:OptimProb2PPDS} can be solved by P-PDS~\cite{Pock2011PPDS} given by Alg. 1.
The proximity operator of $\| \cdot \|_{1}$ is calculated by
\begin{equation}
    \label{eq:ProxL1norm}
    \lbrack \prox_{\ParamStepsize{} \| \cdot \|_1}(\VarOne) \rbrack_{i} = \sgn(\ElementOne{i}) \max \left\{ 0, |\ElementOne{i}| - \ParamStepsize{} \right\},
\end{equation}
which is equivalent to soft thresholding.
The projections onto $\BallFidel$ and $\SetRange$ are calculated by
\begin{align}
    \label{eq:ProjL2ball}
    \Projection{\BallFidel}(\VarOne) &= 
    \begin{cases}
        \VarOne, & \text{if } \VarOne \in \BallFidel, \\ 
        \HSIObsv + \frac{\varepsilon (\VarOne - \HSIObsv)}{\| \VarOne - \HSIObsv \|_2}, & \text{otherwise,}
    \end{cases} \\
    \label{eq:ProjRange}
    \lbrack \Projection{\SetRange} (\VarOne) \rbrack_{i} 
    &= 
    \begin{cases} 
            \MinRange, & \text{if } \ElementOne{i} < \MinRange, \\ 
            \MaxRange, & \text{if } \ElementOne{i}> \MaxRange, \\ 
            \ElementOne{i}, & \text{otherwise.} 
    \end{cases}
\end{align}
The projection onto $\BallSparse$ can be efficiently computed by a fast $\ell_{1}$-ball projection algorithm~\cite{Condat2016L1ball}.
% According to \cite{Naganuma2023PPDS}, we set the stepsize parameters as
% \begin{align}
%     \label{eq:StepsizeParams}
%     & \ParamStepsize{\HSIClean} = \frac{1}{53}, \: \ParamStepsize{\NoiseSparse} = 1, \nonumber \\
%     & \ParamStepsize{\VarDual{1}} = \ParamStepsize{\VarDual{2}} = \ParamStepsize{\VarDual{3}} = \ParamStepsize{\VarDual{4}} = \ParamStepsize{\VarDual{5}} = \frac{1}{2}.
% \end{align}
According to \cite{Naganuma2023PPDS}, we set the stepsize parameters as
$\ParamStepsize{\HSIClean} = \frac{1}{53}$, $\ParamStepsize{\NoiseSparse} = 1$, $\ParamStepsize{\VarDual{1}} = \ParamStepsize{\VarDual{2}} = \ParamStepsize{\VarDual{3}} = \ParamStepsize{\VarDual{4}} = \ParamStepsize{\VarDual{5}} = \frac{1}{2}$.